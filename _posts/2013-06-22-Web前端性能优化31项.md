---
layout: post
category : 学习笔记
tagline: "Supporting tagline"
tags : [web前端, 性能优化, PageSpeed]
---

{% include JB/setup %}

# “ High performance web sites lead to higher visitor engagement, retention and conversions ”

高性能网站会吸引以及留住更多的访问者！—— 引用于[Google PageSpeed](https://developers.google.com/speed/ "文档介绍")

## Web性能最佳实践

当你用Page Speed(“Page Speed”是什么？请参考我的博文【[用Page Speed插件来提高网站性能](http://pigerla.com/%E9%98%85%E8%AF%BB%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/2013/06/20/%E7%94%A8Page-Speed%E6%8F%92%E4%BB%B6%E6%9D%A5%E6%8F%90%E9%AB%98%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD/ "进入博文"))】来“描述”网页时，它会依赖一系列不同的“准则”来评估你的网页性能。这些“准则”是学Web前端技术的最佳实践。
<!--break-->

你可以应用在任何阶段的web前端开发中去，接下来将会一一列出每条“准则”是怎样的？都具有哪些内容？因此，不管你是否在使用Page Speed这个插件，或者说你还是Web前端开发的新手，都没关系，你随时都可以运用这些优化准则，希望你能够更好地实现这些优化准则以及把这些优化技术融入到Web前端开发中去。

## 性能最佳实践分6大类

Page Speed工作原理是在网页加载下来的过程中，Page Speed就根据这些准则对当前网页进行一系列评估。
而性能最佳实践涉及到很多过程，包括“1、解析DNS域名”、“2、建立TCP协议的链接”和“3、传送HTTP协议请求”等，下载Web资源，从缓存那里获取资源，解析并执行脚本和加载及渲染页面。从这里也可以看出，Page Speed做的工作还是蛮多的，
别看这个过程是有点短暂……如标题显示，这些准则可归为6大分类，包含不同方面页面加载的优化。

+ ** 优化缓存 ** ——使你的应用程序数据与逻辑完全从网络上下载下来并保存在本地上。

+ ** 最小化“往返时间”次数 ** ——减少“请求-响应”的来回次数

+ ** 最小化请求头文件 ** ——减少上传量大小

+ ** 最小化下载量 ** ——减少响应次数、下载次数和需要缓存的页面。

+ ** 优化浏览器渲染页面性能 ** ——提高浏览器的页面排版

+ ** 优化移动终端 ** ——根据移动网络和移动（终端）设备来优化一个网站使得协调一致

## 1. 优化缓存

大部分的网页资源都会很频繁的改变，例如CSS文件、图片、JavaScript文件等。而这些资源通过网络下载下来是需要一定时间的，如何把时间缩短呢？HTTP缓存通过浏览器或者代理器允许这些文件可以保存至本地上，或者缓存一段时间。这些文件资源一旦缓存了起来，浏览器或者代理器就会直接从缓存区里取出而不需要通过网络重新下载下载再缓存起来。所以说，这种方法（机制）是可以达到双赢的效果： **减少【round-trip time】(RTT)次数** 和 **减少下载量** ，另外，还能显著地减少网络带宽，因此当你托管你的网站时，就会减少你的服务费用，省下一笔钱。

+ ** 1. 使用浏览器缓存 **

+ ** 2. 利用代理缓存 **

## 1. 使用浏览器缓存

HTTP/S 通过浏览器支持在本地上缓存静态（变动较少）的资源，我们推荐你配置你的网络服务器，明确地设置缓存的头信息，利用这些头信息都应用到所以的静态资源上，而不只是局部，例如单纯只是图片。可以被缓存起来的文件有JS、CSS、图片、媒体文件、PDF文件和Flash文件等，一般来说，HTML却不是静态文件，所以不建议被缓存。

HTTP/1.1 提供如下缓存“响应头”的方法：

+ * Expires * 和 * Cache-Control: max-age * ：这两个“指标”都指定了资源的保存时间（生命周期），
换句话说，就是浏览器可以一直使用本地缓存直到从网络服务器上检测到有新的版本可以用为止。在这个期间，浏览器不会向服务器发出任何一个GET请求资源。

+ * Last-Modified * 和 * ETag * ：在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，
内容是你请求的资源，同时有一个 * Last-Modified *的属性标记此文件在服务期端最后被修改的时间，
格式类似这样：Last-Modified: Fri, 12 May 2006 18:53:33 GMT
客户端第二次请求此URL时，根据 HTTP 协议的规定，浏览器会向服务器传送 If-Modified-Since 报头，询问该时间之后文件是否有被修改过：If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT
如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed.）状态码，内容为空，这样就节省了传输数据量。
当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。而 *ETag*是唯一地标识一个资源的，可以是任意值。
格式为：ETag: "50b1c1d4f775c61:df3"客户端的查询更新格式是这样的：If-None-Match: W/"50b1c1d4f775c61:df3"
如果ETag没改变，则返回状态304然后不返回，这也和Last-Modified一样。

指定 * Expires *和 * Cache-Control: max-age *两者其中一个，和 * Last-Modified *和 * ETag *两者其中一个都是很有必要的，但是如果都定义两者的话，那就是一种浪费而且是不必要的！